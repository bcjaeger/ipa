% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scrimp.R
\name{scrimp_vars}
\alias{scrimp_vars}
\title{Score imputations for specific variables}
\usage{
scrimp_vars(
  data_imputed,
  data_missing,
  data_complete,
  fun_ctns_error = yardstick::rsq_trad_vec,
  fun_intg_error = yardstick::rsq_trad_vec,
  fun_bnry_error = yardstick::kap_vec,
  fun_catg_error = yardstick::kap_vec
)
}
\arguments{
\item{data_imputed}{an imputed data frame.}

\item{data_missing}{the unimputed data frame.}

\item{data_complete}{a data frame containing the 'true' values
that were 'missing'.}

\item{fun_ctns_error}{a function that will evaluate errors for
continuous variables. Continuous variables have type \code{double}.
Default is to use R-squared (see \code{\link[yardstick:rsq]{yardstick::rsq()}}).}

\item{fun_intg_error}{a function that will evaluate errors for
integer valued variables. Default is to use R-squared
(see \code{\link[yardstick:rsq]{yardstick::rsq()}}).}

\item{fun_bnry_error}{a function that will evaluate errors for
binary variables (i.e., factors with 2 levels). Default
is to use kappa agreement (see \code{\link[yardstick:kap]{yardstick::kap()}}).}

\item{fun_catg_error}{a function that will evaluate errors for
categorical variables (i.e., factors with >2 levels). Default
is to use kappa agreement (see \code{\link[yardstick:kap]{yardstick::kap()}}).}
}
\value{
a \code{\link[tibble:tibble]{tibble::tibble()}} with columns \code{variable}, \code{type},
and \code{score}. The \code{score} column comprises output from the
\code{error} functions.
}
\description{
If you want to evaluate how accurately an imputation
procedure fills in missing values, \code{scrimp_vars} can help. Generally,
\code{scrimp_vars} only applies to artificial situations where you
ampute your data (i.e., make missing values), then impute it.
For a more general imputation validation procedure, see \link{scrimp_mdl}.
}
\note{
Kappa agreement is a similar to measuring classification accuracy,
but is normalized by the accuracy that would be expected by chance
alone and is very useful when one or more classes have large frequency
distributions.
}
\examples{

df_complete <- data.frame(a = 1:10, b = 1:10, c = 1:10, d=1:10,
  fctr = letters[c(1,1,1,1,1,2,2,2,2,2)])

df_miss = df_complete
df_miss[1:3, 1] <- NA
df_miss[2:4, 2] <- NA
df_miss[3:5, 3] <- NA
df_miss[4:6, 5] <- NA


imputes <- list(a=1:3, b=2:4, c=3:5, fctr = factor(c('a','a','b')))

df_imputed <- fill_na(df_miss, vals = imputes)

scored <- scrimp_vars(df_imputed, df_miss, df_complete)
}
