% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scrimp.R
\name{scrimp_mdl}
\alias{scrimp_mdl}
\title{Score imputations based on accuracy of downstream models}
\usage{
scrimp_mdl(train_imputed, test_imputed, outcome, .fun = NULL, .fun_args = NULL)
}
\arguments{
\item{train_imputed}{an imputed data frame with training data.}

\item{test_imputed}{an imputed data frame with testing data.}

\item{outcome}{column name(s) of outcomes. These values can be
provided as symbols (e.g., outcome = c(a,b,c) for multiple outcomes
or outcome = a for one outcome) or character values (e.g., outcome =
c('a','b','c') for multiple outcomes or outcome = 'a' for a single
outcome).}

\item{.fun}{a function with at least three inputs: \code{.trn} \code{.tst},
and \code{outcome}. \code{scrimp_mdl()} will call your function as follows:
\code{.fun(.trn = train_imputed, .tst = test_imputed, outcome = outcome, ...)},
where \code{...} is filled in by \code{.fun_args}. Generally, \code{.fun} should
\enumerate{
\item develop a prediction model using \code{.trn}
\item create predicted values for observations in \code{.tst}
\item evaluates the predictions using a summary measure (e.g., R-squared,
area underneath the ROC curve, Brier score, etc.).
}

See example below where a function using random forests is applied.}

\item{.fun_args}{a named list with additional arguments for \code{.fun}.}
}
\value{
If you supply your own function using \code{.fun}, \code{scrimp_mdl}
will return the output of \code{.fun}.  If \code{.fun} is left unspecified,
a named list is returned with components
\itemize{
\item \code{model}: the model fitted to the training data.
\item \code{preds}: the model's predicted values for testing data,
\item \code{score}: a numeric value indicating prediction accuracy.
}

The list's contents will vary depending on \code{.fun_args}. By
default, when \code{fun} is unspecified, \code{.fun_args} is governed
by the \code{\link[=net_args]{net_args()}} function, which includes inputs of \code{keep_mdl}
and \code{keep_prd}. The default value for \code{keep_mdl} is \code{FALSE} while
that of \code{keep_prd} is \code{TRUE}, so users who want to receive a list
including \code{model} should write \code{.fun_args = net_args(keep_mdl = TRUE)}
when calling \code{scrimp_mdl}.
}
\description{
For \strong{single} imputation strategies,
imputing data more accurately generally correlates with
higher accuracy of prediction models fitted to the imputed data.
\code{scrimp_mdl} facilitates this type of validation.
}
\examples{

data("diabetes")
trn <- diabetes$missing[1:200, ]
tst <- diabetes$missing[-c(1:200), ]

imputes <- brew_soft(trn, outcome = diabetes) \%>\%
  mash(with = masher_soft(si_maxit = 1000)) \%>\%
  ferment(data_new = tst) \%>\%
  bottle() \%>\%
  purrr::pluck('wort') \%>\%
  dplyr::slice(5)

# use the default glmnet logistic regression model
dflt_output <- scrimp_mdl(
  train_imputed = imputes$training[[1]],
  test_imputed  = imputes$testing[[1]],
  outcome = diabetes)

# use default glmnet and include fitted model in list output
include_mdls <- scrimp_mdl(
  train_imputed = imputes$training[[1]],
  test_imputed  = imputes$testing[[1]],
  outcome = diabetes,
  .fun_args = net_args(keep_mdl = TRUE))

\dontrun{
# write your own function:
# note the function inputs can be ordered however you like, but the
# names of the inputs **must** include be .trn, .tst, and outcome
rngr_fun <- function(outcome, .trn, .tst, num_trees){

  # make a model formula
  formula <- as.formula(paste(outcome, '~ .'))
  # fit a random forest with ranger (probability = TRUE -> predicted probs)
  mdl <- ranger::ranger(formula = formula, data = .trn,
    probability = TRUE, num.trees = num_trees)
  # prediction from ranger returns matrix with two columns, we need the 2nd.
  prd <- predict(mdl, data = .tst)$predictions[ , 2, drop = TRUE]
  # compute model AUC
  yardstick::roc_auc_vec(.tst[[outcome]], prd)

}

scrimp_mdl(
  train_imputed = imputes$training[[1]],
  test_imputed  = imputes$testing[[1]],
  outcome = 'diabetes',
  .fun = rngr_fun,
  .fun_args = list(num_trees = 100)
)#'
}
}
