% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute_soft.R
\name{impute_soft}
\alias{impute_soft}
\title{Soft imputation}
\usage{
impute_soft(
  data_ref,
  data_new = NULL,
  cols = dplyr::everything(),
  rank_max_ovrl = min(dim(data_ref) - 1),
  rank_max_init = min(2, rank_max_ovrl),
  rank_stp_size = 1,
  lambda = seq(rank_max_ovrl * 0.6, 1, length.out = 10),
  grid = FALSE,
  restore_data = TRUE,
  verbose = 1,
  bs = TRUE,
  bs_maxit = 20,
  bs_thresh = 1e-09,
  bs_row.center = FALSE,
  bs_col.center = TRUE,
  bs_row.scale = FALSE,
  bs_col.scale = TRUE,
  si_type = "als",
  si_thresh = 1e-05,
  si_maxit = 100,
  si_final.svd = TRUE
)
}
\arguments{
\item{data_ref}{a data frame.}

\item{data_new}{an optional data frame. If supplied, then \code{data_ref}
will be used as a reference dataset for \code{data_new} and the output
will contain imputed values for \code{data_new}. If not supplied,
the output will contain imputed values for \code{data_ref}.}

\item{cols}{columns that should be imputed and/or used to impute other
columns. Supports tidy select functions (see examples).}

\item{rank_max_ovrl}{an integer value that restricts the rank of the
solution for all \code{softImpute} fits.}

\item{rank_max_init}{an integer value that restricts the rank of the
solution for the first \code{softImpute} fit. Sequential fits may have
higher rank depending upon \code{rank_max_ovrl}, \code{rank_stp_size}, and \code{grid}.}

\item{rank_stp_size}{an integer value that indicates how much the maximum
rank of \code{softImpute} fits should increase between iterations.}

\item{lambda}{nuclear-norm regularization parameter. If \code{lambda = 0},
the algorithm reverts to "hardImpute", for which convergence is typically
slower, and to local minimum. Ideally lambda should be chosen so that
the solution reached has rank slightly less than rank.max. See also
\code{lambda0()} for computing the smallest \code{lambda} with a zero solution.}

\item{grid}{a logical value. If \code{TRUE}, all combinations of rank and
lambda are used to fit \code{softImpute} models. If \code{FALSE}, then one
fit is supplied for each value of \code{lambda}, and increasing maximum
ranks are paired with decreasing values of \code{lambda}.}

\item{restore_data}{a logical value. If \code{TRUE}, the variable types
of the imputed values will match those of the original data. If \code{FALSE},
the imputed values are returned in a one-hot encoded format.}

\item{verbose}{an integer value of 0, 1, or 2. If \code{verbose = 0}, nothing
is printed. If \code{verbose = 1}, messages are printed to the console showing
what general steps are being taken in the imputation process. If
\code{verbose = 2}, all relevant information on convergence is printed in
addition to general messages.}

\item{bs}{a logical value. If \code{TRUE}, \code{\link[softImpute:biScale]{softImpute::biScale()}} is applied
to \code{data_ref} or \code{rbind(data_ref, data_new)} prior to fitting \code{softImpute}
models.}

\item{bs_maxit}{an integer indicating the maximum number of iterations
for the \code{biScale} algorithm.}

\item{bs_thresh}{convergence threshold for the \code{biScale} algorithm.}

\item{bs_row.center}{a logical value. If \code{TRUE}, row centering
will be performed. If \code{FALSE} (default), then nothing is done.}

\item{bs_col.center}{a logical value. If \code{TRUE} (default), column centering
will be performed. If \code{FALSE}, then nothing is done.}

\item{bs_row.scale}{a logical value. If \code{TRUE}, row scaling
will be performed. If \code{FALSE} (default), then nothing is done.}

\item{bs_col.scale}{a logical value. If \code{TRUE} (default), column scaling
will be performed. If \code{FALSE}, then nothing is done.}

\item{si_type}{two algorithms are implemented, type="svd" or the default
type="als". The "svd" algorithm repeatedly computes the svd of the
completed matrix, and soft thresholds its singular values. Each new
soft-thresholded svd is used to re-impute the missing entries. For
large matrices of class "Incomplete", the svd is achieved by an
efficient form of alternating orthogonal ridge regression. The
"als" algorithm uses this same alternating ridge regression, but
updates the imputation at each step, leading to quite substantial
speedups in some cases. The "als" approach does not currently
have the same theoretical convergence guarantees as the
"svd" approach.}

\item{si_thresh}{convergence threshold for the \code{softImpute} algorithm,
measured as the relative change in the Frobenius norm between two
successive estimates.}

\item{si_maxit}{maximum number of iterations for the \code{softImpute}
algorithm.}

\item{si_final.svd}{only applicable to \code{si_type = "als"}. The alternating
ridge-regressions do not lead to exact zeros. With the default
\code{final.svd = TRUE}, at the final iteration, a one step unregularized
iteration is performed, followed by soft-thresholding of the
singular values, leading to hard zeros.}
}
\value{
a data frame with fitting parameters and imputed values.
}
\description{
The \code{softImpute} algorithm is used to impute missing values.
For more details, see \link[softImpute:softImpute]{softImpute}
}
\details{
\strong{Multiple imputation}: The number of imputations returned depends on
\code{rank_max_init}, \code{rank_max_ovrl}, \code{rank_stp_size}, \code{lambda}, and \code{grid}.
If \code{grid} is \code{FALSE}, then there will be \code{length(lambda)} imputed value
sets in the returned output, and they will be based on fitted
\code{softImpute} models with increasing maximum ranks. Generally, these ranks
are \code{seq(rank_max_init, rank_max_ovrl, by = rank_stp_size)}, but will
be automatically adjusted to have consistency with (1) \code{lambda} and
(2) the maximum allowed rank for \code{data_ref} as needed. If \code{grid} is
\code{TRUE}, then every combination of \code{lambda} and the rank sequence
will be fitted and the output will contain one set of imputed values
for each combination.

\strong{Rank inputs}: If rank is sufficiently large, and with \code{si_type="svd"},
the \code{softImpute} algorithm solves the nuclear-norm convex
matrix-completion problem (see Reference 1). In this case the number
of nonzero singular values returned will be less than or equal to
the maximum rank. If smaller ranks are used, the solution is not
guaranteed to solve the problem, although still results in good local
minima. The rank of a \code{softImpute} fit should not exceed
\verb{min(dim(data_ref) - 1}.

\strong{biScale} The \code{\link[softImpute:biScale]{softImpute::biScale()}} function is more flexible than
the current function indicates. Specifically, \code{biScale} allows users
to supply vectors to its row/column centering/scaling inputs that will
in turn be used to center/scale the corresponding rows/columns.
\code{impute_soft()} is more strict and does not offer this option.
Also, \code{impute_soft()} uses different default values to increase the
likelihood of the \code{biScale} algorithm converging quickly.
}
\references{
\enumerate{
\item Rahul Mazumder, Trevor Hastie and Rob Tibshirani (2010) Spectral
Regularization Algorithms for Learning Large Incomplete Matrices,
http://www.stanford.edu/~hastie/Papers/mazumder10a.pdf,
Journal of Machine Learning Research 11 (2010) 2287-2322
}
}
