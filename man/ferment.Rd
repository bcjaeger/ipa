% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ferment.R
\name{ferment}
\alias{ferment}
\alias{is_fermented}
\title{Ferment a brew}
\usage{
ferment(brew, ...)

is_fermented(brew)
}
\arguments{
\item{brew}{an \code{ipa_brew} object.}

\item{...}{Name-value pairs of expressions. The name of each
argument will be the name of a new variable in the \code{wort}
of the \code{ipa_brew} object. The value of each argument should be
an object created using the \link{test_nbrs} or \link{test_stkr} functions.
The inputs of these functions will determine how testing data
are imputed.}
}
\description{
Missing values can occur in the training data,
testing data, and validation data. An important requirement
for missing value strategies is that only information from
the training data should be used to impute missing data.

Unfortunately, some imputation strategies are not designed to
work this way! For example, \code{softImpute} imputes missing
values based on the index of the missing value in the training
data, and this doesn't generalize to testing data because
testing data (by definition) are not in the training data.

Fortunately, \code{ferment} gives you options. For example, you
can use \code{softImpute} to impute missing training data, and then
use \code{kneighbors} to impute the testing data by matching the
testing observations to their nearest neighbors in the training
data. More specifically, you can tell \code{ferment} to impute the
testing data using either the original unimputed training data
or using each of the imputed training datasets, separately.
The same options apply for all \code{ipa_brew} objects.
}
\note{
What is a \code{wort}? A component of a \code{brew} object that
contains imputed datasets, models used to impute those datasets,
and the corresponding hyper-parameters of those models.
}
\examples{

data <- data.frame(
  x1 = 1:10,
  x2 = 10:1,
  x3 = rnorm(10),
  outcome = 11 + runif(10)
)

data[1:2, 1] = NA
data[5:6, 2] = NA

new_data = data.frame(
  x1 = 1:10,
  x2 = 10:1,
  x3 = rnorm(10),
  outcome = 11 + runif(10)
)

new_data[6:7, 1] = NA
new_data[2:3, 2] = NA

knn_brew <- brew(data, outcome = outcome, flavor = 'kneighbors')

knn_spiced <- spice(
  brew = knn_brew,
  neighbors = c(3, 5),
  aggr_neighbors = c(TRUE, FALSE)
)

knn_mashed <- mash(knn_spiced)

# use test_nbrs to impute new data with nearest neighbors
knn_fermed <- ferment(knn_mashed, test = test_nbrs(new_data))

# new column called 'test' is in the wort now
knn_fermed$wort


}
