% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/imputation.R
\name{boil}
\alias{boil}
\alias{boil.soft_brew}
\alias{boil.neighbors_brew}
\alias{boil.rangers_brew}
\title{Boil a brew}
\usage{
boil(mash, verbose = FALSE, ...)

\method{boil}{soft_brew}(mash, verbose = FALSE, ...)

\method{boil}{neighbors_brew}(mash, verbose = FALSE, ...)

\method{boil}{rangers_brew}(mash, verbose = FALSE, ...)
}
\arguments{
\item{mash}{a \code{brew} object that has been mashed (see \link{mash_soft})}

\item{verbose}{\code{TRUE} or \code{FALSE}. if \code{TRUE}, output will be
printed to the console indicating the ranks of solutions found
for the softImpute fits.}

\item{...}{arguments passed on to \link[softImpute:softImpute]{softImpute},
\link[gower:gower_dist]{gowerD},}
}
\description{
When an IPA is boiled, hops and spices are added
to the wort, creating flavors for enjoyment. For an \code{ipa} \code{brew}
object, this step involves adding training data to the analysis
and then creating imputation models based on that data.
}
\section{Methods (by class)}{
\itemize{
\item \code{soft_brew}: boil a soft brew, valid parameters for \code{...} are
\code{type}, \code{thresh}, \code{maxit}, \code{trace.it}, and \code{final.svd} (see notes).

\item \code{neighbors_brew}: boil a soft brew, valid parameters for \code{...} are
\code{eps} and \code{nthread} (see notes).

\item \code{rangers_brew}: boil a ranger's brew, valid parameters for \code{...} are
\code{num.trees}, \code{sample.fraction}, \code{splitrule}, \code{formula},
\code{num.random.splits},\code{maxiter}, \code{seed}, and \code{case.weights}
(see notes).
}}

\note{
For \code{soft_brew} objects, valid inputs for \code{...} are
\itemize{
\item \code{type}: two algorithms are implements, type="svd" or the default
type="als". The "svd" algorithm repeatedly computes the svd of the
completed matrix, and soft thresholds its singular values. Each new
soft-thresholded svd is used to re-impute the missing entries. For
large matrices of class "Incomplete", the svd is achieved by an
efficient form of alternating orthogonal ridge regression. The
"als" algorithm uses this same alternating ridge regression, but
updates the imputation at each step, leading to quite substantial
speedups in some cases. The "als" approach does not currently
have the same theoretical convergence guarantees as the
"svd" approach.
\item \code{thresh}: convergence threshold, measured as the relative
change in the Frobenius norm between two successive estimates.
\item \code{maxit}: maximum number of iterations.
\item \code{final.svd}: only applicable to type="als". The alternating
ridge-regressions do not lead to exact zeros. With the default
final.svd=TRUE, at the final iteration, a one step unregularized
iteration is performed, followed by soft-thresholding of the
singular values, leading to hard zeros.
}

For \code{neighbors_brew} objects, valid inputes for \code{...} are
\itemize{
\item \code{eps}:	(numeric; optional) Computed numbers (variable ranges) smaller
than eps are treated as zero.
\item \code{weights}	(numeric; optional) A vector of weights of length
equal to the number of predictor variables in the mash that defines
the weight applied to each component of the gower distance.
}
}
